from myutils import *
import pdb


def eval_two_volumes_maxpool(root, target, pool_kernel, device):
    pre = read_nifti(root)
    label = read_nifti(target)
    k = pool_kernel
    s = max(1, k - 1)
    kernel = (k, k, k)
    pre[pre > 0] = 1
    label[label > 0] = 1
    pre = pre.astype(np.uint8)
    label = label.astype(np.uint8)

    pre = torch.Tensor(pre).view((1, 1, *pre.shape)).to(device)
    label = torch.Tensor(label).view((1, 1, *label.shape)).to(device)

    pre = torch.nn.functional.max_pool3d(pre, kernel, 1, 0)
    label = torch.nn.functional.max_pool3d(label, kernel, 1, 0)

    dice_score = dice_error(pre, label)

    total_loss_iou = iou(pre, label).cpu()
    total_loss_tiou = t_iou(pre, label).cpu()
    clrecall, clacc, recall, acc = soft_cldice_f1(pre, label)
    cldice = (2. * clrecall * clacc) / (clrecall + clacc)

    print('\n Validation IOU: {}\n T-IOU: {}'
          '\n ClDice: {} \n ClAcc: {} \n ClRecall: {} \n Dice-score: {}'
          '\n Acc: {} \n Recall: {}'
          .format(total_loss_iou, total_loss_tiou, cldice, clacc, clrecall, dice_score, acc, recall, ':.8f'))
    return {'iou': total_loss_iou,
            'tiou': total_loss_tiou,
            'cldice': cldice,
            'acc': clacc,
            'recall': clrecall,
            'score': dice_score}


def eval_two_volume_dirs_maxpool(target, root, data, pool_kernel, device):
    pre = read_nifti(join(root, data))
    label = read_nifti(join(target, data))
    k = pool_kernel
    s = max(1, k - 1)
    kernel = (k, k, k)
    stride = (s, s, s)
    pre[pre > 0] = 1
    label[label > 0] = 1
    pre = pre.astype(np.uint8)
    label = label.astype(np.uint8)

    pre = torch.Tensor(pre).view((1, 1, *pre.shape)).to(device)
    label = torch.Tensor(label).view((1, 1, *label.shape)).to(device)

    pre = torch.nn.functional.max_pool3d(pre, kernel, 1, 0)
    label = torch.nn.functional.max_pool3d(label, kernel, 1, 0)

    dice_score = dice_error(pre, label)

    total_loss_iou = iou(pre, label).cpu()
    total_loss_tiou = t_iou(pre, label).cpu()
    recall, acc = soft_cldice_f1(pre, label)
    cldice = (2. * recall * acc) / (recall + acc)

    print('\n Validation IOU: {}\n T-IOU: {}'
          '\n ClDice: {} \n ClAcc: {} \n ClRecall: {} \n Dice-score: {}'
          .format(total_loss_iou, total_loss_tiou, cldice, acc, recall, dice_score, '.8f'))
    return {'iou': total_loss_iou,
            'tiou': total_loss_tiou,
            'cldice': cldice,
            'acc': acc,
            'recall': recall,
            'score': dice_score}


def avg(num, total):
    return total / num


if __name__ == "__main__":
    # ========== evaluate only one cube of 600*600*450 ========== #
    val_root = ""  # grould-truth label of 600*600*450 cube for evaluation
    val_target = ""  # folder with nnUNet prediction generated by `nnUNet_predict` command
    kernel_size = 10  # maxpooling kernel size 5,10,15
    device = torch.device('cuda:0')
    loss = eval_two_volumes_maxpool(val_target, val_root, kernel_size, device)

    # ========== evaluate cubes from a directory(not used)  ========== #
    data_root = ""  # folder with ground-truth labels
    data_target = ""  # folder with predictions
    iou_1, tiou_1, cldice_1, acc_1, recall_1, dice_score_1 = 0, 0, 0, 0, 0, 0
    count = 0
    for data in sorted(os.listdir(data_target)):
        if ".nii.gz" in data or ".tiff" in data:
            count += 1
            loss = eval_two_volume_dirs_maxpool(data_target, data_root, data, kernel_size, device)
            iou_1 += loss['iou']
            tiou_1 += loss['tiou']
            cldice_1 += loss['cldice']
            acc_1 += loss['acc']
            recall_1 += loss['recall']
            dice_score_1 += loss['score']
    iou_t = avg(count, iou_1)
    tiou_t = avg(count, tiou_1)
    cldice_t = avg(count, cldice_1)
    acc_t = avg(count, acc_1)
    recall_t = avg(count, recall_1)
    score_t = avg(count, dice_score_1)
    print('\n Validation IOU: {}\n T-IOU: {}'
          '\n ClDice: {} \n ClAcc: {} \n ClRecall: {} \n Dice-score: {}'
          .format(iou_t, tiou_t, cldice_t, acc_t, recall_t, score_t, '.8f'))

